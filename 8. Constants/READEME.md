# 8. 第8章 常量

本章重点介绍什么时候、为什么和怎样使用关键字**const**。最后讨论关键字**volatile**，它是**const**的“近亲”（因为它们都关系到变化）并具有完全相同的语法。

**const**的最初动机是取代预处理器#**defines**来进行值替代。从这以后它曾被用于指针、函数变量、返回类型、类对象以及成员函数。

## 8.1 值替代

当用C语言进行程序设计时，预处理器可以不受限制地建立宏并用它来替代值。因为**预处理器只做些文本替代，它既没有类型检查概念，也没有类型检查功能，所以预处理器的值替代会产生一些微小的问题**，这些问题在C++中可以通过使用**const**值而避免。

C中用值替代名字的典型用法是：`#define BUFSIZE 100`，**BUFSIZE**是一个名字，它只是在预处理期间存在，因此它不占用存储空间且能放在一个头文件里，目的是为使用它的所有编译单元提供一个值。

大多数情况，**BUFSIZE**的工作方式与普通变最类似；而且没有类型信息。C++用**const**把值替代带进编译器领域来消除这些问题：`const int bufsize = 100;`。

这样就可以在编译时编译器需要知道这个值的任何地方使用`bufsize`，同时编译器还可以执行**常量折叠**(**constant folding**)，也就是说，编译器在编译时可以通过必要的计算把一个复杂的常量表达式通过缩减简单化。这一点在数组定义里显得尤其重要：`char buf[bufsize];`。

因为预处理器会引入错误，所以我们应该完全用`const`取代`#define`的值替代。

### 8.1.1 头文件里的const

要使用`const`而非`#define`，同样必须把`const`定义放进头文件里。这样，通过包含头文件，可把`const`定义单独放在一个地方并把它分配给一个编译单元。C++中的`const`默认为**内部连接**(**internal linkage**)，也就是说，`const`仅在`const`被定义过的文件里才是可见的，而在连接时不能被其他编译单元看到。当定义一个`const`时，**必须赋一个值给它，除非用extern作出了清楚的说明**：`extern const int bufsize;`。

通常C++编译器并不为`const`创建存储空间，相反它把这个定义保存在它的符号表里。但是，上面的`extern`强制进行了存储空间分配（另外还有一些情况，如取一个`const`的地址，也要进行存储空间分配），由于`extern`意味着使用外部连接，因此必须分配存储空间，这也就是
说有几个不同的编译单元应当能够引用它，所以它必须有存储空间。

### 8.1.2 const的安全性

`const`的作用不仅限于在常数表达式里代替`#defines`。如果用运行期间产生的值初始化一个变量而且知道在变量生命期内是不变的，则用`const`限定该变量是程序设计中的一个很好的做法。

> 代码示例：
[C8_01_Safecons.cpp]()

```C++
   // C08: Safecons.cpp
    // Using const of safety
    #include <iostream>
    using namespace std;

    const int i = 100;  // Typical constant
    const int j = i + 10; // Value from const expr
    long address = (long)&j;    // Force storage
    char buf[j + 10];   // Still a const expression

    int main()
    {
        cout << "type a character & CR: ";
        const char c = cin.get();   // can't change
        const char c2 = c + 'a';
        cout << c2;
    } 
```

i是一个编译期间的`const`，j是从i中计算出来的，由于i是一个`const`，j的计算值来自一个常数表达式，而它自身也是一个编译期间的`const`。紧接下面的一行需要j的地址，所以迫使编译器给j分配存储空间。即使分配了存储空间，把i值保存在程序的某个地方，由于编译器知道j是`const`, 而且知道j值是有效的，因此，这仍不能妨碍在决定数组`buf`的大小时使用j。

在主函数`main()`里，对于标识符c有另一种`const`，因为其值在编译期间是不知道的。这意味着需要存储空间，而编译器不想保留它的符号表里的任何东西（和C语言的行为一样）。初始化必须在定义点进行，而且一且初始化，其值就不能改变。**如果想让一个值不变，就应该使之成为const。**

### 8.1.3 集合

`const`可以用于集合，但必须保证编译器不会复杂到把一个集合保存到它的符号表中，所以必须分配内存。在这种情况下，`const`意味着**不能改变的一块存储空间**。然而，**不能在编译期间使用它的值**，因为编译器在编译期间不需要知道存储的内容。下面代码是非法的：

> 代码示例：
[C8_02_Constag.cpp]()

```C++
    // C08: Constag.cpp
    // Constents and aggregates
    const int i[] = {1, 2, 3, 4};

    // ! float f[i[3]];     // Illegal
    struct S
    {
        int i, j;
    };

    const S s[] = {{1, 2}, {3, 4}};

    // double d[s[1].j];    // Illegal

    int main()
    {}
```

在一个数组定义里，编译器必须能产生这样的代码，它们移动栈指针来存储数组。在上面这两种非法定义里，编译器给出“提示”是因为它不能在数组定义里找到一个常数表达式。

### 8.1.4 与C语言的区别

