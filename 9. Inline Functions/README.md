# 第9章 内联函数

**宏**(**macro**)的实现是用预处理器而不是编译器。在C++中，使用预处理器宏存在两个问题。第一个问题：宏看起来像一个函数调用，但并不总是这样。这样就隐藏了难以发现的错误。第二个问题是C++特有的：预处理器不允许访问类的成员数据。这意味着预处理器宏不能用作类的成员函数。

本章将介绍C++中预处理器宏存在的问题、在C++中如何用内联函数解决这些问题以及使用内联函数的方针和内联函数的工作机制。

## 9.1 预处理器的缺陷

预处理器宏存在问题的关键**是我们可能认为预处理器的行为和编译器的行为一样**。

考虑如下简单例子：`#define F (x) (x + 1)`，假如有一个F的调用：`F(1)`，预处理器展开它：`(x) (x + 1)(1)`，出现这个问题是因为在宏定义中`F`和括号之间存在空格。当这个空格取消后，调用宏时可以有空格空隙，如`F (1)`，依然可以正确地展开为：`(1 + 1)`。

这里存在两个问题。第一个问题是**表达式在宏内展开，所以它们的优先级不同于所期望的优先级**。例如：`#define FLOOR(x, b) x>=b?0:1`，但如果用表达式作参数：`if(FLOOR(a&0xf, 0x07))`，宏将展开为：`if(a&0x0f>=0x07>0:1)`，因为`&`的优先级比`>=`的低，所以宏的展开结果将与原本所期望的不一致。

可通过在宏定义内的各个地方使用括弧来解决：`#define FLOOR(x,b) ((x)>=(b)?0:1)`。

第二个问题：不像普通函数，**每次在宏中使用一个参数，都对这个参数求值**。只要使用普通变量调用宏仅，求值就无危险。但假如参数求值有副作用，那么结果可能出乎预料。

例如，下面这个宏决定它的参数是否在一定范围：`#define BAND(x) (((x)>5 && (x)<10) ? (x) : 0)`，只要使用一个“普通”参数，宏和真的函数的工作方式非常相似，但仍存在问题，例如：

> 代码示例：
[C9_01_MacroSideEffects.cpp]()

```C++

```